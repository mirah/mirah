require 'fileutils'
require 'rbconfig'
require 'duby/transform'
require 'duby/ast'
require 'duby/typer'
require 'duby/compiler'
begin
  require 'bitescript'
rescue LoadError
  $: << File.dirname(__FILE__) + '/../../bitescript/lib'
  require 'bitescript'
end
require 'duby/jvm/compiler'
require 'duby/jvm/typer'
Dir[File.dirname(__FILE__) + "/duby/plugin/*"].each {|file| require "#{file}" if file =~ /\.rb$/}
require 'jruby'

module Duby
  def self.run(*args)
    DubyImpl.new.run(*args)
  end

  def self.compile(*args)
    DubyImpl.new.compile(*args)
  end

  def self.parse(*args)
    DubyImpl.new.parse(*args)
  end

  def self.plugins
    @plugins ||= []
  end

  def self.reset
    @plugins.each {|x| x.reset if x.respond_to?(:reset)}
  end

  def self.print_error(message, position)
    puts "#{position.file}:#{position.start_line + 1}: #{message}"
    file_offset = 0
    startline = position.start_line
    endline = position.end_line
    start_offset = position.start_offset
    end_offset = position.end_offset
    # don't try to search dash_e
    # TODO: show dash_e source the same way
    if File.exist? position.file
      File.open(position.file).each_with_index do |line, lineno|
        line_end = file_offset + line.size
        skip = [start_offset - file_offset, line.size].min
        if lineno >= startline && lineno <= endline
          print line
          if skip > 0
            print ' ' * (skip)
          else
            skip = 0
          end
          if line_end <= end_offset
            puts '^' * (line.size - skip)
          else
            puts '^' * [end_offset - skip - file_offset, 1].max
          end
        end
        file_offset = line_end
      end
    end
  end
end

# This is a custom classloader impl to allow loading classes with
# interdependencies by having findClass retrieve classes as needed from the
# collection of all classes generated by the target script.
class DubyClassLoader < java::security::SecureClassLoader
  def initialize(parent, class_map)
    super(parent)
    @class_map = class_map
  end
  
  def findClass(name)
    bytes = @class_map[name].to_java_bytes
    defineClass(name, bytes, 0, bytes.length)
  end

  def loadClass(name, resolve)
    cls = findLoadedClass(name)
    if cls == nil
      if @class_map[name]
        cls = findClass(name)
      else
        cls = super(name, false)
      end
    end

    resolveClass(cls) if resolve

    cls
  end
end

class DubyImpl
  def run(*args)
    ast = parse(*args)
    main = nil
    class_map = {}

    # generate all bytes for all classes
    compile_ast(ast) do |outfile, builder|
      bytes = builder.generate
      name = builder.class_name.gsub(/\//, '.')
      class_map[name] = bytes
    end

    # load all classes
    dcl = DubyClassLoader.new(java.lang.ClassLoader.system_class_loader, class_map)
    class_map.each do |name,|
      cls = dcl.load_class(name)
      # TODO: using first main; find correct one
      main ||= cls.get_method("main", java::lang::String[].java_class) #rescue nil
    end

    # run the main method we found
    if main
      begin
        main.invoke(nil, [args.to_java(:string)].to_java)
      rescue java.lang.Exception => e
        e = e.cause if e.cause
        raise e
      end
    else
      puts "No main found"
    end
  end

  def compile(*args)
    process_flags!(args)

    expand_files(args).each do |duby_file|
      if duby_file == '-e'
        @filename = '-e'
        next
      elsif @filename == '-e'
        ast = parse('-e', duby_file)
      else
        ast = parse(duby_file)
      end
      exit 1 if @error

      compile_ast(ast) do |filename, builder|
        filename = "#{@dest}#{filename}"
        FileUtils.mkdir_p(File.dirname(filename))
        bytes = builder.generate
        File.open(filename, 'w') {|f| f.write(bytes)}
      end
      @filename = nil
    end
  end

  def parse(*args)
    process_flags!(args)
    @filename = args.shift

    if @filename
      if @filename == '-e'
        @filename = 'DashE'
        src = args[0]
      else
        src = File.read(@filename)
      end
    else
      print_help
      exit(1)
    end
    Duby::AST.type_factory = Duby::JVM::Types::TypeFactory.new(@filename)
    begin
      ast = Duby::AST.parse_ruby(src, @filename)
    rescue org.jrubyparser.lexer.SyntaxException => ex
      Duby.print_error(ex.message, ex.position)
      raise ex if @verbose
    end
    @transformer = Duby::Transform::Transformer.new
    ast = @transformer.transform(ast, nil)
    @transformer.errors.each do |ex|
      Duby.print_error(ex.message, ex.position)
      raise ex.cause || ex if @verbose
    end
    @error = @transformer.errors.size > 0
    ast
  end

  def compile_ast(ast, &block)
    typer = Duby::Typer::JVM.new(@filename, @transformer)
    typer.infer(ast)
    begin
      typer.resolve(false)
    ensure
      puts ast.inspect if @verbose

      failed = !typer.errors.empty?
      if failed
        puts "Inference Error:"
        typer.errors.each do |ex|
          Duby.print_error(ex.message, ex.node.position)
          puts ex.backtrace if @verbose
        end
        exit 1
      end
    end

    compiler = @compiler_class.new(@filename)
    ast.compile(compiler, false)
    compiler.generate(&block)
  end

  def process_flags!(args)
    while args.length > 0 && args[0] =~ /^-/
      case args[0]
      when '--verbose', '-V'
        Duby::Typer.verbose = true
        Duby::AST.verbose = true
        Duby::Compiler::JVM.verbose = true
        @verbose = true
        args.shift
      when '--java', '-j'
        require 'duby/jvm/source_compiler'
        @compiler_class = Duby::Compiler::JavaSource
        args.shift
      when '--dir', '-d'
        args.shift
        @dest = File.join(args.shift, '')
      when '--plugin', '-p'
        args.shift
        plugin = args.shift
        require "duby/plugin/#{plugin}"
      when '-I'
        args.shift
        $: << args.shift
      when '--classpath', '-c'
        args.shift
        args.shift.split(RbConfig::CONFIG['PATH_SEPARATOR']).each do |path|
          $CLASSPATH << path
        end
      when '--help', '-h'
        print_help
        exit(0)
      else
        puts "unrecognized flag: " + args[0]
        print_help
        exit(1)
      end
    end
    @compiler_class ||= Duby::Compiler::JVM
  end
  
  def print_help
    $stdout.print "#{$0} [flags] <files or \"-e SCRIPT\">
  -V, --verbose\t\tVerbose logging
  -j, --java\t\tOutput .java source (jrubyc only)
  -d, --dir DIR\t\tUse DIR as the base dir for compilation, packages
  -p, --plugin PLUGIN\tLoad and use plugin during compilation
  -c, --classpath PATH\tAdd PATH to the Java classpath for compilation
  -h, --help\t\tPrint this help message
  -e\t\t\tCompile or run the script following -e (naming it \"DashE\")"
  end 

  def expand_files(files)
    expanded = []
    files.each do |filename|
      if File.directory?(filename)
        Dir[File.join(filename, '*')].each do |child|
          if File.directory?(child)
            files << child
          elsif child =~ /\.duby$/
            expanded << child
          end
        end
      else
        expanded << filename
      end
    end
    expanded
  end
end

if __FILE__ == $0
  Duby.run(ARGV[0], *ARGV[1..-1])
end
